// Force Node runtime (Edge can't use JSZip/Buffer)
export const runtime = 'nodejs'
// Give the function breathing room for zip generation
export const maxDuration = 15

import { NextResponse } from 'next/server';
import JSZip from 'jszip';

// Mock data generators
function generateRiskSummary() {
  return {
    score: 16,
    band: 'LOW' as const,
    confidence: 97,
    updatedAt: new Date().toISOString(),
    timeframe: 'ytd' as const,
    source: {
      name: 'Algorithmic Cartel Detection Engine',
      freshnessSec: 20,
      quality: 0.96
    }
  };
}

function generateEvents() {
  const events = [
    { time: '2025-09-09T19:30:00Z', type: 'Market coordination', severity: 'LOW', band: 'LOW' },
    { time: '2025-09-09T19:25:00Z', type: 'Information flow anomaly', severity: 'LOW', band: 'LOW' },
    { time: '2025-09-09T19:20:00Z', type: 'Regime switch', severity: 'LOW', band: 'LOW' },
    { time: '2025-09-09T19:15:00Z', type: 'Price leadership change', severity: 'MEDIUM', band: 'AMBER' },
    { time: '2025-09-09T19:10:00Z', type: 'Volume spike', severity: 'LOW', band: 'LOW' }
  ];
  
  return events.map(event => ({
    timestamp: event.time,
    event_type: event.type,
    severity: event.severity,
    risk_band: event.band
  }));
}

function generateDataSources() {
  return {
    updatedAt: new Date().toISOString(),
    items: [
      {
        name: 'Market Data Feed',
        status: 'OK' as const,
        freshnessSec: 15,
        quality: 0.98
      },
      {
        name: 'Price Analytics Engine',
        status: 'OK' as const,
        freshnessSec: 20,
        quality: 0.96
      },
      {
        name: 'Volume Monitor',
        status: 'OK' as const,
        freshnessSec: 12,
        quality: 0.94
      }
    ]
  };
}

function generateSummary() {
  return `# Algorithmic Cartel Detection - Evidence Package

## Executive Summary

This evidence package contains comprehensive analysis results from the Algorithmic Cartel Detection (ACD) system, implementing the methodological framework outlined in Brief 55+.

## Methodology Overview

### Brief 55+ Framework
- **Information Cascade Vulnerability Model (ICVM)**: Analyzes how information flows between market participants
- **Vulnerability Mapping Model (VMM)**: Identifies structural vulnerabilities in algorithmic trading systems
- **Regime Detection**: Monitors for shifts between competitive and coordinated market states

### Detection Methods
1. **Price Leadership Analysis**: Identifies dominant price-setting behaviors
2. **Volume Synchronization**: Detects coordinated trading patterns
3. **Information Flow Mapping**: Tracks data dependencies between algorithms
4. **Regime Switching Models**: Statistical models to detect coordination phases

## Current Risk Assessment

- **Overall Risk Score**: 16/100 (LOW)
- **Confidence Level**: 97%
- **Risk Band**: LOW
- **Assessment Period**: Year-to-Date (YTD)
- **Last Updated**: ${new Date().toISOString()}

## Key Findings

1. **Market Coordination**: Minimal evidence of algorithmic coordination
2. **Information Flow**: Normal competitive information patterns observed
3. **Regime Stability**: Market operating in competitive regime
4. **Compliance Status**: All metrics within acceptable thresholds

## Data Sources

- Market Data Feed: 98% quality, 15s freshness
- Price Analytics Engine: 96% quality, 20s freshness  
- Volume Monitor: 94% quality, 12s freshness

## Recommendations

1. Continue monitoring for regime changes
2. Maintain current surveillance protocols
3. Review quarterly for emerging patterns
4. Escalate if risk score exceeds 40

---
Generated by ACD Monitor v0.5.1-palette-lock
${new Date().toISOString()}`;
}

export async function GET(request: Request) {
  const url = new URL(request.url);
  const mode = url.searchParams.get('mode') ?? 'ready'; // ready|queued

  const now = new Date();
  const bundleId = `acd-evidence-${now.toISOString().slice(0, 10).replace(/-/g, '')}-${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}`;

  if (mode === 'queued') {
    const payload = {
      requestedAt: now.toISOString(),
      status: 'QUEUED' as const,
      bundleId,
      estSeconds: 45
    };
    return NextResponse.json(payload);
  }

  // Generate the evidence package
  try {
    const zip = new JSZip();
    
    // Add summary.md
    zip.file('summary.md', generateSummary());
    
    // Add risk_summary.json
    zip.file('risk_summary.json', JSON.stringify(generateRiskSummary(), null, 2));
    
    // Add events.csv
    const events = generateEvents();
    const csvHeader = 'timestamp,event_type,severity,risk_band\n';
    const csvContent = csvHeader + events.map(e => `${e.timestamp},${e.event_type},${e.severity},${e.risk_band}`).join('\n');
    zip.file('events.csv', csvContent);
    
    // Add data_source.json
    zip.file('data_source.json', JSON.stringify(generateDataSources(), null, 2));
    
    // Generate the zip file as Uint8Array to avoid Buffer on Edge
    const binary: Uint8Array = await zip.generateAsync({ type: 'uint8array' });
    
    const filename = `acd-evidence-${now.toISOString().slice(0,16).replace(/[-:T]/g,'')}.zip`;
    
    // Return a binary Response with download headers
    return new NextResponse(binary, {
      status: 200,
      headers: {
        'Content-Type': 'application/zip',
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Cache-Control': 'no-store',
      },
    });
    
  } catch (error) {
    console.error('Error generating evidence package:', error);
    return NextResponse.json(
      { error: 'Failed to generate evidence package' },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  // Handle POST requests for evidence export
  const body = await request.json().catch(() => ({}));
  const mode = body.mode ?? 'ready';

  const now = new Date();
  const bundleId = `acd-evidence-${now.toISOString().slice(0, 10).replace(/-/g, '')}-${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}`;

  if (mode === 'queued') {
    const payload = {
      requestedAt: now.toISOString(),
      status: 'QUEUED' as const,
      bundleId,
      estSeconds: 45
    };
    return NextResponse.json(payload);
  }

  // For POST requests, return the same zip generation logic
  try {
    const zip = new JSZip();
    
    // Add summary.md
    zip.file('summary.md', generateSummary());
    
    // Add risk_summary.json
    zip.file('risk_summary.json', JSON.stringify(generateRiskSummary(), null, 2));
    
    // Add events.csv
    const events = generateEvents();
    const csvHeader = 'timestamp,event_type,severity,risk_band\n';
    const csvContent = csvHeader + events.map(e => `${e.timestamp},${e.event_type},${e.severity},${e.risk_band}`).join('\n');
    zip.file('events.csv', csvContent);
    
    // Add data_source.json
    zip.file('data_source.json', JSON.stringify(generateDataSources(), null, 2));
    
    // Generate the zip file as Uint8Array to avoid Buffer on Edge
    const binary: Uint8Array = await zip.generateAsync({ type: 'uint8array' });
    
    const filename = `acd-evidence-${now.toISOString().slice(0,16).replace(/[-:T]/g,'')}.zip`;
    
    // Return a binary Response with download headers
    return new NextResponse(binary, {
      status: 200,
      headers: {
        'Content-Type': 'application/zip',
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Cache-Control': 'no-store',
      },
    });
    
  } catch (error) {
    console.error('Error generating evidence package:', error);
    return NextResponse.json(
      { error: 'Failed to generate evidence package' },
      { status: 500 }
    );
  }
}
